<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Standard EcmaScript</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/blood.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-background-image="images/andre-medvedev-787013-unsplash.jpg" data-background-opacity="0.3">
					<h3>EcmaScript</h3>
          <h4 class="red">O silniku, który napędza JavaScript</h4>
          <h6 class="fragment">oraz szybki przegląd nowości</h6>
				</section>
				<section data-background="images/letsrock.gif">
					<h2>No to jedziemy!</h2>
				</section>
				<section>
					<section>
						<h3>Czym jest ECMAScript?</h3>
						<h6 class="fragment">
							ECMAScript to specyfikacja opisująca obiektowy język ogólnego przeznaczenia
            </h6>
            <p class="fragment">
							Można o nim powiedzieć, że jest to "metajęzyk" będący standardem dla innych języków
            </p>
            <p class="fragment red">
							I nie da się w nim nic napisać, ponieważ opisuje on tylko składnie
						</p>
          </section>
          <section>
						<h3>Implementacje ECMAScript</h3>
						<ul>
							<li class="fragment">JavaScript</li>
							<li class="fragment">ActionScript</li>
							<li class="fragment">JScript</li>
						</ul>
					</section>
					<section>
						<h3>Wersje ES</h3>
						<ul>
							<li>Przed rokiem 2000 - ES1, ES2, <strong class="red">ES3</strong></li>
							<li>ES4 - porzucone</li>
							<li>ES5/<strong class="red">5.1</strong> - 2009/2011</li>
							<li><strong class="red">ES6</strong> - ES2015</li>
							<li><strong>ES7</strong> - ES2016</li>
              <li><strong>ES8</strong> - ES2017</li>
              <li><strong>ES9</strong> - ES2018</li>
              <li><strong>ES10</strong> - ES2019</li>
							<li><strong>ES.Next / ES Harmony</strong></li>
						</ul>
					</section>
				</section>
				<section data-background="images/es.gif">
				</section>
				<section>
          <h4>ES5.1 jest obsługiwany wszędzie</h4>
          <h4>Po co mamy się przejmować ES.Next?</h4>
          <ul>
            <li class="fragment">Bo to przyszłość</li>
            <li class="fragment">Mniej problemów przy pisaniu w czystym JS</li>
            <li class="fragment">Większość nowoczesnych bibliotek wykorzystuje nowości z ES.Next</li>
            <li class="fragment">Jest używany przez 87% front-end deweloperów (<a href="https://2018.stateofjs.com/javascript-flavors/es6/">https://2018.stateofjs.com/javascript-flavors/es6/</a>)</li>
            <li class="fragment">Przeglądarki adaptują nowości niezwykle szybko (<a href="http://kangax.github.io/compat-table/es6/">http://kangax.github.io/compat-table/es6/</a>)</li>
          </ul>
				</section>
				<section>
					<section>
						<h3>Najważniejsze nowości</h3>
						<ul>
							<li>LET i CONST (ES6)</li>
							<li>Classes (ES6)</li>
							<li>Arrow Functions (ES6)</li>
							<li>Modules (ES6)</li>
							<li>Template Literals (ES6)</li>
							<li>Promises (ES6)</li>
              <li>Enhanced Object Literal (ES6)</li>
						</ul>
					</section>
					<section>
						<h3>I jeszcze te</h3>
						<ul>
							<li>Spread Operator (ES6/ES7)</li>
							<li>Rest Parameters (ES6)</li>
							<li>Default Parameters (ES6)</li>
							<li>for...of loop (ES6)</li>
							<li>Destructuring Assignment (ES6)</li>
							<li>Symbols, Maps, Sets, Proxy (ES6)</li>
						</ul>
					</section>
					<section>
						<h3>I takie tam</h3>
						<ul>
							<li>Exponentiation operator (ES7)</li>
							<li>New Array Methods (ES6/ES7)</li>
							<li>Async Functions (ES8)</li>
						</ul>
          </section>
          <section>
						<h3>No dobra, to już ostatnie!</h3>
						<ul>
							<li>Promise.prototype.finally() (ES9)</li>
							<li>Rest, Spread in objects (ES9)</li>
              <li>Array.flat/flatMap (ES10)</li>
              <li>String.trimStart/trimEnd (ES10)</li>
              <li>Optional catch binding (ES10)</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h3>LET i CONST</h3>
						<div class="left-box">
							<p><span class="red">var</span> - zasięg funkcyjny</p>
						</div>
						<div class="right-box">
							<p><span class="red">let/const</span> - zasięg blokowy</p>
						</div>
					</section>
					<section>
						<h4>LET i CONST</h4>
                        <div>
                            <pre><code class="hljs">
const key = "abc123";
let points = 50;
let winner = false;

if (points > 40) {
  let winner = true; // nowa zmienna
}
                            </code></pre>
                        </div>
					</section>
                    <section>
                        <h4>LET i CONST</h4>
                        <p>Temporal Dead Zone</p>
                        <div>
                            <pre><code class="hljs">
function do_something() {
  console.log(bar); // undefined
  console.log(foo); // ReferenceError

  var bar = 1;
  let foo = 2;
}
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>LET i CONST</h4>
                        <p>Nie można nadpisać zmiennej const!</p>
                        <div>
                            <pre><code class="hljs">
const key = 'abc123';

key = 12; // TypeError
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>LET i CONST</h4>
                        <p>Ale można modyfikować obiekty zadeklarowane z użyciem const!</p>
                        <div>
                            <pre><code class="hljs">
const person = {
  name: 'John',
  age: 22
}

person.age = 29;  // bez problemu!
                            </code></pre>
                        </div>
                    </section>
				</section>
                <section>
                    <section>
                        <h3>Klasy</h3>
                        <p class="fragment">Klasy dostarczają prostszą i czytelniejszą składnie do tworzenia obiektów i dziedziczenia po innych</p>
                        <p class="fragment">Zawartość deklaracji i wyrażenia klasowego jest wykonywana w tzw. "strict mode"</p>
                    </section>
                    <section>
                        <h4>Klasy</h4>
                        <p>Kiedyś</p>
                        <pre><code class="hljs">
function Vehicle(name, type) {
  this.name = name;
  this.type = type;
};
 
Vehicle.prototype.getName = function getName() {
  return this.name;
};
 
Vehicle.prototype.getType = function getType() {
  return this.type;
};
                        </code></pre>
                    </section>
                    <section>
                        <h4>Klasy</h4>
                        <p>Obecnie</p>
                        <pre><code class="hljs">
class Vehicle {
  constructor(name, type) {
    this.name = name;
    this.type = type;
  }

  getName() {
    return this.name;
  }

  getType() {
    return this.type;
  }
}
                        </code></pre>
                    </section>
                    <section>
                        <h4>Klasy</h4>
                        <p>Prostsze dziedziczenie</p>
                        <pre><code class="hljs">
class Car extends Vehicle {
  constructor(name) {
    super(name, "car");
  }

  getName() {
    return "Jestem pojazdem: " + super.getName();
  }
}
                        </code></pre>
                    </section>
                    <section>
                        <h4>Klasy</h4>
                        <p>get / set / static</p>
                        <pre><code class="hljs">
class Car {
  constructor(name) {
    this._name = name;
  } 

  set name(name) {
    this._name = name;
  }

  get name() {
    return this._name;
  }

  static create(name) {
    return new Car(name);
  }
}

const car = new Car("Fiat Multipla");
car.name = "Fiat 500";
console.log(car.name); // Zwróci "Fiat 500"

Car.create("Ford"); // Zwraca nowy obiekt typu Car
                        </code></pre>
                    </section>
                    <section>
                        <h4>Klasy</h4>
                        <p>Wyrażenia klasowe</p>
                        <pre><code class="hljs">
let Car = class {
  constructor(name) {
    this._name = name;
  }
};
                        </code></pre>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Arrow functions</h3>
                        <p>Nowy krótszy zapis dla wyrażeń funkcyjnych</p>
                        <div class="left-box">
                            <p>Kiedyś</p>
                            <pre><code class="hljs">
var test = function (value) {
  return value * 2;
};
                            </code></pre>
                        </div>
                        <div class="right-box">
                            <p>Obecnie</p>
                            <pre><code class="hljs">
const test = (value) => {
  return value * 2;
};
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Arrow functions</h4>
                        <div>
                            <p>Funkcja natychmiastowa z użyciem funkcji strzałkowej</p>
                            <pre><code class="hljs">
(() => {
  // jakiś kod
}());
                            </code></pre>
                        </div>
                        <div>
                            <p>Skrócony zapis w przypadku funkcji zwracających wynik</p>
                            <pre><code class="hljs">
const test = value => value * 2;
                            </code></pre>
                        </div>
                    </section>
                    <section>
                      <h4>Arrow functions</h4>
                      <p>Automatyczne wiązanie kontekstu</p>
                      <div>
                          <p>Kiedyś</p>
                          <pre><code class="hljs">
function Person() {
  var that = this;
  that.age = 0;

  setInterval(function() {
    that.age++;
  }, 1000);
}
                        </code></pre>
                      </div>
                    </section>
                    <section>
                        <h4>Arrow functions</h4>
                        <p>Automatyczne wiązanie kontekstu</p>
                        <div>
                            <p>Obecnie</p>
                            <pre><code class="hljs">
  function Person() {
    this.age = 0;
  
    setInterval(() => {
      this.age++;
    }, 1000);
  }
                              </code></pre>
                          </div>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Moduły</h3>
                        <p>Dzięki nim jesteśmy w stanie pisać złożone aplikacje podzielone na wiele modułów!</p>
                        <p class="fragment">Moduły ES6 mają włączony domyślnie "strict mode" <span class="red">(żegnaj "use strict")</span></p>
                    </section>
                    <section>
                        <h4>Moduły</h4>
                        <div>
                          <p>Dawne dzieje</p>
                            <pre><code class="hljs">
;(function() {
  "use strict";

  // reszta logiki aplikacji
}(window));
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Moduły</h4>
                        <p>Importowanie funkcji/bibliotek</p>
                        <div>
                            <pre><code class="hljs">
import { square, diag } from 'lib';
import test from 'lib';

console.log(square(11));   // 121

console.log(diag(4, 3));   // 5
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Moduły</h4>
                        <p>Eksportowanie funkcji/bibliotek</p>
                        <div>
                            <pre><code class="hljs">
export const sqrt = Math.sqrt;

export function square(x) {
  return x * x;
}

export function diag(x, y) {
  return sqrt(square(x) + square(y));
}

export default function test() { return "test"; }
                            </code></pre>
                        </div>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Template Literals</h3>
                        <div class="left-box">
                            <p>Kiedyś</p>
                            <pre><code class="hljs">
let word = "world";
console.log("Hello " + word);
                            </code></pre>
                        </div>
                        <div class="right-box">
                            <p>Obecnie</p>
                            <pre><code class="hljs">
let word = "world";
console.log(`Hello ${word}`);
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h3>Template Literals</h3>
                        <div>
                            <p>Przykład pętli</p>
                            <pre><code class="hljs">
${movies.map(movie => `<li class="filmotique-movie col-xs-12 col-md-4">
  <div class="box">
    <span class="movie-title">${movie.title}</span>
    <span class="movie-date">${movie.release_date}</span>
  </div>
</li>`).join("")};
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h3>Teksty wielolinijkowe</h3>
                        <div>
                            <p>Kiedyś</p>
                            <pre><code class="hljs">
let text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n\t" 
           + "Morbi ornare sapien in consequat pellentesque.";
                            </code></pre>
                        </div>
                        <div>
                            <p>Obecnie</p>
                            <pre><code class="hljs">
let text = `Lorem ipsum dolor sit amet, consectetur adipiscing elit.
               Morbi ornare sapien in consequat pellentesque.`;
                            </code></pre>
                        </div>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Promises (obietnice)</h3>
                        <p>Czytelny sposób na pisanie kodu asynchronicznego</p>
                        <div>
                            <pre><code class="hljs">
let wait = new Promise((resolve, reject) => {
  setTimeout(resolve, 1000);
}).then(() => {
  console.log('WoW');
});

const wait2 = () => new Promise((resolve, reject) => {
  setTimeout(resolve, 1000);
});

wait2().then((val) => {
  console.log(val);
}).catch((err) => {
  console.log(err.message);
});
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Promises</h4>
                        <p>Więcej niż jedna</p>
                        <div>
                            <pre><code class="hljs">
const urls = [ 
  'http://www.api.com/items/1234',
  'http://www.api.com/items/4567'
],
itemPromises = urls.map(fetch);

Promise.all(itemPromises)  
  .then(function(results) {
    results.forEach(function(item) {
      // process item
    });
  })
  .catch(function(err) {
    console.log(`Failed: ${err}`);
  });
                            </code></pre>
                        </div>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Rozszerzony literał obiektu</h4>
                        <p>Skrócony zapis właściwości</p>
                        <div class="left-box">
                            <p>Kiedyś</p>
                            <pre><code class="hljs">
function f(x, y) {
  return { 
    x: x, 
    y: y 
  };
}
                            </code></pre>
                        </div>
                        <div class="right-box">
                            <p>Obecnie</p>
                            <pre><code class="hljs">
function f(x, y) {
  return { 
    x, 
    y
  };
}
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Rozszerzony literał obiektu</h4>
                        <p>Skrócona deklaracja metod</p>
                        <div class="left-box">
                            <p>Kiedyś</p>
                            <pre><code class="hljs">
let ob = {
  method: function() {
    return "Hello!";
  }
};
                            </code></pre>
                        </div>
                        <div class="right-box">
                            <p>Obecnie</p>
                            <pre><code class="hljs">
let ob = {
  method() {
    return "Hello!";
  }
};
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Rozszerzony literał obiektu</h4>
                        <p>Dynamiczne klucze</p>
                        <div>
                            <p>Kiedyś</p>
                            <pre><code class="hljs">
let ob = {};
let dynamicKey = "dynamic" + Date.now();
ob[dynamicKey] = "test";
                            </code></pre>
                        </div>
                        <div>
                            <p>Obecnie</p>
                            <pre><code class="hljs">
let ob = {
  ["dynamic" + Date.now()]: "test"
};
                            </code></pre>
                        </div>
                    </section>
                </section>
                 <section>
                    <section>
                        <h3>Spread operator</h3>
                        <div>
                            <pre><code class="hljs">
function myFunction(x, y, z) { ... }
const args = [0, 1, 2];

myFunction(...args);


function myFunction(v, w, x, y, z) { ... }
const args = [0, 1];

myFunction(-1, ...args, 2, ...[3]);
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Spread operator</h4>
                        <div>
                            <pre><code class="hljs">
let parts = ['shoulders', 'knees']; 
let lyrics = ['head', ...parts, 'and', 'toes']; 
// ["head", "shoulders", "knees", "and", "toes"]

let obj1 = { foo: 'bar', x: 42 };
let obj2 = { foo: 'baz', y: 13 };

let clonedObj = { ...obj1 };
// { foo: "bar", x: 42 }
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Spread operator</h4>
                        <div>
                            <p>Kiedyś</p>
                            <pre><code class="hljs">
function modifyState(state, modifiedValue) {
  return Object.assign({}, state, {
    field: modifiedValue
  });
}
                            </code></pre>
                        </div>
                        <div>
                            <p>Obecnie</p>
                            <pre><code class="hljs">
function modifyState(state, modifiedValue) {
  return {
    ...state, 
    field: modifiedValue 
  };
}
                            </code></pre>
                        </div>
                    </section>
                </section>
				<section>
                    <section>
                        <h3>Rest parameters</h3>
                        <div>
                            <pre><code class="hljs">
function consoleOut(something, ...somethingElse) {
  console.log(something);
  console.log(somethingElse);
}

consoleOut("test", 1, 2, 3, 4);
// "test", 1, 2, 3, 4

let array = [1, 2, 3];   // Uwaga!
consoleOut(...array);    // To spread operator, nie rest!
                            </code></pre>
                        </div>
                    </section>
					<section>
						<h4>Rest parameters</h4>
						<div>
							<p>Kiedyś</p>
							<pre><code class="hljs">
function argsFun() {
  var args = Array.prototype.slice.call(arguments);
  args.forEach(function (arg) {
    console.log(arg);
  });
}
							</code></pre>
						</div>
						<div>
							<p>Obecnie</p>
							<pre><code class="hljs">
function argsFun(...args) {
  args.forEach((arg) => {
    console.log(arg);
  });
}
							</code></pre>
						</div>
					</section>
				</section>
                <section>
                    <h3>Parametry domyślne</h3>
                    <div>
                        <pre><code class="hljs">
function multiply(a, b = 1) {
  return a * b;
}

multiply(2, 2); // 4
multiply(2, 1); // 2
multiply(2);    // 2

// przekazywanie wyniku funkcji? Nie ma problemu!
function arrayMultiply(a, b = multiply(2)) {
  return [a, b];
}

arrayMultiply(1); // [1, 2]
                        </code></pre>
                    </div>
                </section>
                <section>
                    <section>
                        <h3>Pętla For...of</h3>
                        <p>Nowy rodzaj pętli dla obiektów po których można iterować np. dla Array, String, Map, Set, parametru arguments itd.</p>
                    </section>
                    <section>
                        <h4>Pętla For...of</h4>
                        <div>
                            <pre><code class="hljs">
let iterable = [10, 20, 30];

for (let value of iterable) {
  value += 1;
  console.log(value);
}
// 11
// 21
// 31
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Pętla For...of</h4>
                        <p>Przykład ze stringiem</p>
                        <div>
                            <pre><code class="hljs">
let iterable = 'boo';

for (let value of iterable) {
  console.log(value);
}
// "b"
// "o"
// "o"
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Pętla For...of</h4>
                        <p>Przykład z obiektem</p>
                        <div class="left-box">
                            <p>Kiedyś</p>
                            <pre><code class="hljs">
let iterable = {
  a: 1
};

for (var key in iterable) {
  console.log(iterable[key]); // 1 i coś jeszcze...
}
                            </code></pre>
                        </div>
                        <div class="right-box">
                            <p>Obecnie</p>
                            <pre><code class="hljs">
let iterable = {
  a: 1
};

for (let key of iterable) {
  console.log(iterable[key]); // 1
}
                            </code></pre>
                        </div>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Destrukturyzacja obiektu</h3>
                        <div>
                            <pre><code class="hljs">
let foo = { bar: 'test', baz: 3 };
let { bar, baz, fooz } = foo;

console.log(bar);  //  'test'
console.log(baz);  //  3
console.log(fooz);  //  undefined
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Destrukturyzacja obiektu</h4>
                        <p>Aliasy</p>
                        <div>
                            <pre><code class="hljs">
let foo = { bar: 'test', baz: 3 };
let { bar: a, baz: b } = foo;

console.log(a);  //  'test'
console.log(b);  //  3
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Destrukturyzacja obiektu</h4>
                        <p>Wyciąganie właściwości z obiektu</p>
                        <div>
                            <pre><code class="hljs">
let foo = { bar: { a: 'test', b: 'lol' } };

let { bar: { a, b: c } } = foo;

console.log(a);  //  'test'
console.log(c);  //  'lol'
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Destrukturyzacja obiektu</h4>
                        <p>Dynamiczne klucze</p>
                        <div>
                            <pre><code class="hljs">
let key = 'test';
let { [key]: foo } = { test: 'bar' };
console.log(foo);  //  'bar'
                            </code></pre>
                        </div>
                        <p>Domyślne wartości</p>
                        <div>
                            <pre><code class="hljs">
let { foo = 2 } = { foo: undefined };
console.log(foo);  // 2
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Destrukturyzacja obiektu</h4>
                        <p>Destrukturyzacja w parametrach</p>
                        <div>
                            <pre><code class="hljs">
const ob = {
  a: 1,
  b: 2,
  c: 3
};

function getObject({ a, b, c }) { ... }

getObject(ob); 
                            </code></pre>
                        </div>
                        <p>Destrukturyzacja w wyrażeniu import</p>
                        <div>
                            <pre><code class="hljs">
import { map, foreach } from "lodash";
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Destrukturyzacja obiektu</h4>
                        <p>Destrukturyzacja tablic</p>
                        <div>
                            <pre><code class="hljs">
let letters = ['a', 'b', 'c];
let [a, b, c] = letters;
// a = 'a', b = 'b', c = 'c'

let letters = ['a', 'b', 'c];
let [, b, c] = letters;
// undefined, b = 'b', c = 'c'
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Destrukturyzacja obiektu</h4>
                        <p>Zamiana wartości zmiennych</p>
                        <div>
                            <pre><code class="hljs">
let a = 1, b = 2;
[a, b] = [b, a];

console.log(a); // 2
console.log(b); // 1
                            </code></pre>
                        </div>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Symbols, Maps, Sets, Proxy</h3>
                        <p>Nowe typy obiektów</p>
                    </section>
                    <section>
                        <h3>Symbol</h3>
                        <div>
                            <p>Są to tzw. tokeny zwracające za każdym razem unikalny identyfikator</p>
                            <pre><code class="hljs">
let symbol1 = Symbol();
let symbol2 = Symbol('symbol2');
                            </code></pre>
                        </div>
                        <div>
                            <p>Każdy symbol zwrócony przez funkcję Symbol() jest unikalny</p>
                            <pre><code class="hljs">
symbol1 === symbol2; // false
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h3>Map (słownik)</h3>
                        <p>Mapa przechowuje pary klucz - wartość</p>
                        <div>
                            <pre><code class="hljs">
let map = new Map();

map.set('foo', 123);
map.get('foo');  // 123

map.has('foo'); // true
map.delete('foo');
map.has('foo');  // false
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Map</h4>
                        <p>Ustawienie elementów w konstruktorze</p>
                        <div>
                            <pre><code class="hljs">
let map = new Map([
  [ 1, 'one' ],
  [ 2, 'two' ],
  [ 3, 'three' ]
]);
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>WeakMap</h4>
                        <p>Podobny do zwykłego obiektu Map, ale w tym przypadku każdy klucz musi być obiektem</p>
                        <p>WeakMap nie posiada silnych referencji dla kluczy, zapobiega więc wyciekom pamięci gdy obiekty przestaną istnieć</p>
                        <div>
                            <pre><code class="hljs">
const map = new WeakMap();
map.set(1, 2);
// TypeError: 1 is not an object!

const map = new WeakMap();
map.set({ a: 1 }, 2);
                            </code></pre>
                        </div>
                    </section>
                    <section>
                        <h4>Set (zbiór)</h4>
                        <p>It’s a collection for unique values</p>
                        <div>
                            <pre><code class="hljs">
let set = new Set();
set.add(1);
set.add('1');
set.add({ key: 'value' });

console.log(set); // Set {1, '1', Object {key: 'value'}}
                            </code></pre>
                        </div>
                        <p>Set doesn’t allow to add duplicates!</p>
                    </section>
                    <section>
                        <h4>WeakSet</h4>
                        <p>Is a Set that doesn’t prevent its values from being garbage-collected</p>
                        <div>
                            <pre><code class="hljs">
let set = new WeakSet();
set.add(1);
set.add('1');
set.add({ key: 'value' });

console.log(set); // WeakSet {1, '1', Object {key: 'value'}}
                            </code></pre>
                        </div>
                        <p>WeakSet doesn’t allow to add duplicates!</p>
                    </section>
                </section>
				<section>
					<h3>Operator potęgowania (ES7)</h3>
					<div class="left-box">
						<p>Kiedyś</p>
						<pre><code class="hljs">
Math.pow(2, 4);
						</code></pre>
					</div>
					<div class="right-box">
						<p>Obecnie</p>
						<pre><code class="hljs">
2 ** 2;
						</code></pre>
					</div>
				</section>
				<section>
					<section>
						<h3>Nowe metody tablic</h3>
						<ul>
							<li>Array.from()</li>
							<li>Array.of()</li>
							<li>Array.prototype.entries()</li>
							<li>Array.prototype.keys()</li>
							<li>Array.prototype.values()</li>
							<li>Array.prototype.find()</li>
							<li>Array.prototype.findIndex()</li>
							<li>Array.prototype.fill()</li>
							<li>Array.prototype.includes()</li>
						</ul>
					</section>
					<section>
						<h4>Array.from()</h4>
						<pre><code class="hljs">
function args() {
  Array.from(arguments).forEach(function (arg) {
    console.log(arg);
  });
}
						</code></pre>
					</section>
					<section>
						<h4>Array.of()</h4>
						<pre><code class="hljs">
Array.of(1, 2, 3); // Array [1, 2, 3]

Array.of(256); // Array [256]

new Array(1, 2, 3); // ?

new Array(256); // ?
						</code></pre>
					</section>
					<section>
						<h4>Array.prototype.entries()</h4>
						<h4>Array.prototype.keys()</h4>
						<h4>Array.prototype.values()</h4>
						<pre><code class="hljs">
Array.from([ 'a', 'b' ].entries());
// [ [ 0, 'a' ], [ 1, 'b' ] ]

Array.from([ 'a', 'b' ].keys());
// [ 0, 1 ]

Array.from([ 'a', 'b' ].values());
// [ 'a', 'b' ]
						</code></pre>
					</section>
					<section>
						<h4>Array.prototype.find()</h4>
						<h4>Array.prototype.findIndex()</h4>
						<pre><code class="hljs">
[6, -5, 8].find(x => x < 0);  // -5

[6, 5, 8].find(x => x < 0);  // undefined

[6, -5, 8].findIndex(x => x < 0);  // 1

[6, 5, 8].findIndex(x => x < 0);  // -1
						</code></pre>
					</section>
					<section>
						<h4>Array.prototype.fill()</h4>
						<pre><code class="hljs">
['a', 'b', 'c'].fill(7);  // [ 7, 7, 7 ]
						</code></pre>
					</section>
					<section>
						<h4>Array.prototype.includes() (ES7)</h4>
						<pre><code class="hljs">
["a", "b", "c"].includes("a");  // true

["a", "b", "c"].includes("d");  // false
						</code></pre>
					</section>
				</section>
        <section>
            <section>
                <h3>Funkcje asynchroniczne (ES8)</h3>
                <p class="red">Gorąca nowość!</p>
                <ul>
                    <li class="fragment">Nowy sposób na pisanie asynchronicznego kodu</li>
                    <li class="fragment">Funkcje asynchroniczne są zbudowane na fundamentach obietnic</li>
                    <li class="fragment">Funkcje asynchroniczne nie blokują głównego wątku</li>
                    <li class="fragment">Kod jest ładniejszy, ponieważ wygląda jak synchroniczny</li>
                </ul>
            </section>
            <section>
                <h4>Funkcje asynchroniczne (ES8)</h4>
                <div>
                    <pre><code class="hljs">
const makeRequest = async () => {
  const data = await fetch("endpoint");
  return data;
};
                            </code></pre>
                        </div>
                        <div>
                            <p>Obsługa błędów</p>
                            <pre><code class="hljs">
const makeRequest = async () => {
  try {
    console.log(await fetch("endpoint"));
  } catch (err) {
    console.error(err);
  }
};
                      </code></pre>
                  </div>
              </section>
          </section>
          <section>
              <h3>Opcjonalny parametr catch (ES10)</h3>
              <pre><code class="hljs">
const makeRequest = async () => {
  try {
    console.log(await fetch("endpoint"));
  } catch {
    console.error("Jakiś błąd, nieważne jaki");
  }
};
              </code></pre>
          </section>
          <section>
              <h3>Promise.prototype.finally() (ES9)</h3>
              <pre><code class="hljs">
fetch("endpoint")
  .then(() => console.log("then"))
  .catch(() => console.log("catch"))
  .finally(() => console.log("finally"))
              </code></pre>
          </section>
          <section>
              <h3>Rest i spread w obiektach (ES9)</h3>
              <pre><code class="hljs">
const a = {
  a: "a"
  b: "b1"
};

const b = {
  ...a,
  b: "b2"
}; // { a: "a", b: "b2" }
              </code></pre>
          </section>
          <section>
            <section>
              <h3>Metody flat i flatMap tablic (ES10)</h3>
              <pre><code class="hljs">
let tab = [1, 2, 3, [4, 5, 6]];

tab.flat(); // [1, 2, 3, 4, 5, 6];

tab.flat().flat().flat().flat();
tab.flat(3);
              </code></pre>
            </section>
            <section>
                <h3>Metody flat i flatMap tablic (ES10)</h3>
                <pre><code class="hljs">
  let tab = [1, 2, 3, 4];
  
  tab.flatMap(x => [x * 2]); // [2, 4, 6, 8];
                </code></pre>
              </section>
          </section>
          <section>
              <h3>Metody trimStart i trimEnd obiektu String (ES10)</h3>
              <pre><code class="hljs">
let greeting = "     Tekst i spacje     ";

greeting.trimEnd(); // "     Tekst i spacje";

greeting.trimStart(); // "Tekst i spacje";
              </code></pre>
          </section>
				<section data-background="images/tony.gif" data-background-opacity="0.3">
					<h2>Nowe wersje ES to nowe, ogromne możliwości!</h2>
				</section>
				<section>
          <h3>Dziękuję!</h3>
          <p class="fragment red">Czas na Q/A!</p>
				</section>
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true },
          { src: 'plugin/zoom-js/zoom.js', async: true },
        ],
        history: true,
        width: 1024,
	      height: 768,
			});
		</script>
	</body>
</html>
